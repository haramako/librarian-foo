#!/usr/bin/env ruby

require 'librarian/cli'
require 'json'
require 'yaml'
require 'pp'
require_relative 'site'

module Librarian
  module Foo
    extend self
    extend Librarian

    VERSION = "0.0.1"
    
    class Cli < Librarian::Cli

      module Particularity
        def root_module
          Foo
        end
      end

      extend Particularity

      def init
        copy_file environment.specfile_name
      end

      desc "install", "Resolves and installs all of the dependencies you specify."
      option "quiet", :type => :boolean, :default => false
      option "verbose", :type => :boolean, :default => false
      def install
        ensure!
        resolve!
        install!
      end
    end
      
    class Environment < Librarian::Environment

      def adapter_name
        "foo"
      end

      def adapter_version
        VERSION
      end

      def install_path
        project_path.join("foo")
      end

    end

    module Source
      module Local

        def install!(manifest)
          manifest.source == self or raise ArgumentError

          info { "Installing #{manifest.name} (#{manifest.version})" }

          debug { "Installing #{manifest}" }

          name, version = manifest.name, manifest.version
          found_path = found_path(name)

          install_path = environment.install_path.join(name)
          if install_path.exist?
            debug { "Deleting #{relative_path_to(install_path)}" }
            install_path.rmtree
          end

          install_perform_step_copy!(found_path, install_path)
        end

        def fetch_version(name, extra)
          manifest_data(name)["version"]
        end

        def fetch_dependencies(name, version, extra)
          manifest_data(name)["dependencies"]
        end

      private

        def install_perform_step_copy!(found_path, install_path)
          debug { "Copying #{relative_path_to(found_path)} to #{relative_path_to(install_path)}" }
          FileUtils.mkdir_p(install_path)
          FileUtils.cp_r(filter_path(found_path), install_path)
        end

        def filter_path(path)
          Dir.glob("#{path}/*").reject { |e| e == environment.install_path.to_s }
        end

        def manifest_data(name)
          @manifest_data ||= { }
          @manifest_data[name] ||= fetch_manifest_data(name)
        end

        def fetch_manifest_data(name)
          expect_manifest!(name)

          found_path = found_path(name)
          manifest_path = ManifestReader.manifest_path(found_path)
          ManifestReader.read_manifest(name, manifest_path)
        end

        def manifest?(name, path)
          ManifestReader.manifest?(name, path)
        end

        def expect_manifest!(name)
          found_path = found_path(name)
          return if found_path && ManifestReader.manifest_path(found_path)

          raise Error, "No metadata file found for #{name} from #{self}! If this should be a foo package,"+
            "you might consider contributing a metadata file upstream or forking the cookbook "+
            "to add your own metadata file."
        end

      end

      class Path < Librarian::Source::Path
        include Local
      end
      
      class Git < Librarian::Source::Git
        include Local
      end
      
      class Github
        class << self
          def lock_name
            Git.lock_name
          end

          def from_lock_options(environment, options)
            Git.from_lock_options(environment, options)
          end

          def from_spec_args(environment, uri, options)
            Git.from_spec_args(environment, "https://github.com/#{uri}", options)
          end
        end
      end
      
    end

    class Dsl < Librarian::Dsl

      dependency :foo

      source :site => Source::Site
      source :git => Source::Git
      source :github => Source::Github
      source :path => Source::Path
      source :local => Source::Path
    end

    module ManifestReader
      extend self

      MANIFESTS = %w(metadata.json metadata.yml metadata.yaml)

      def manifest_path(path)
        MANIFESTS.map{|s| path.join(s)}.find{|s| s.exist?}
      end

      def read_manifest(name, manifest_path)
        case manifest_path.extname
        when ".json" then JSON.parse(IO.binread(manifest_path))
        when ".yml", ".yaml" then YAML.load(IO.binread(manifest_path))
        end
      end

      def manifest?(name, path)
        path = Pathname.new(path)
        !!manifest_path(path)
      end

    end
    
  end
end


Librarian::Foo::Cli.bin!
